Amazon

Payment service




start = 0
lastNumber = 10
teleporters = ["3,1", "5,10", "8,2"]
maxValue = 6

def get_final_positions(start, lastNumber, teleporters, maxValue):
    res = set()


    tel_map = {}
    for tel in teleporters:
        src, dest  = tel.split(",")
        tel_map[int(src)] = int(dest)
    for i in range(1, maxValue + 1):
        position = start + i
        if position >= lastNumber:
            position = lastNumber
        
        position = tel_map.get(position,position)
        res.add(position)
    return res

------------------------------------------


def extract_robot_name(part):
    return part.split("_")[0]

import collections
def get_robots(all_parts, required_parts):
    res = []
    robot_map = collections.defaultdict(set)
    required_parts = set(required_parts.split(","))
    for parts in all_parts:
        robot, part = parts.split("_")
        robot_map[robot].add(part)
    
    for robot, robot_map_part in robot_map.items():
        if all(part in robot_map_part for part in required_parts):
            res.append(robot)
    return res
    pass

# Test usage
all_parts = [
    "Rosie_claw",
    "Rosie_sensors",
    "Optimus_sensors",
    "Dustie_case",
    "Rust_sensors",
    "Rosie_case",
    "Rust_case",
    "Optimus_speaker",
    "Rosie_wheels",
    "Rosie_speaker",
    "Dustie_case",
    "Dustie_arms",
    "Rust_claw",
    "Dustie_case",
    "Dustie_speaker",
    "Optimus_case",
    "Optimus_wheels",
    "Rust_legs",
    "Optimus_sensors"
]

required_parts_1 = "sensors,case,speaker,wheels"
required_parts_2 = "sensors,case,speaker,wheels,claw"
required_parts_3 = "sensors,motors,claw"

print(get_robots(all_parts, required_parts_1))  # Output: ["Optimus", "Rosie"]
print(get_robots(all_parts, required_parts_2))  # Output: ["Rosie"]
print(get_robots(all_parts, required_parts_3))  # Output: []



---------------------------


start = 6
lastNumber = 10
teleporters = ["3,1", "5,10", "8,2"]
maxValue = 6


def can_reach_last_number(start, lastNumber, teleporters, maxValue):

    tel_map = {}

    for tel in teleporters:
        src, dest = tel.split(",")
        tel_map[int(src)] = int(dest)

    visited = set()
    def dfs(position):
        if position == lastNumber:
            return True
        
        if position > lastNumber:
            return False
        if position in visited:
            return False
        visited.add(position)
        for roll in range(start, maxValue + 1):
            position += roll
            position = tel_map.get(position,position)
            if dfs(position):
                return True

    return dfs(0)

    pass

print(can_reach_last_number(start, lastNumber, teleporters, maxValue))


--------------------

start = 1
end = 10
hurdles = [1, 4]
destination = 6

directions = [2,-2]

def count_reachable_positions(start, end, hurdles, destination):

    visited = set()

    def dfs(position):
        if position in visited:
            return
        
        if position < start or position > end or position in hurdles:
            return
        
        visited.add(position)

        for dir in directions:
            dfs(position + dir)
    
    dfs(destination)
    return visited

    pass

print(count_reachable_positions(start, end, hurdles, destination))


------------------------------




DP based: given a start point and endpoint on number line (1,2,3...10) and list of hurdles [1, 4], 
you can jump forward and backward two steps [2 to 4, or 2 to 1] and you cannot jump if there is hurdle, 
count number of from points you from where can reach to destination. 
You can't go beyond start and end points on the number line.




------------------------
import collections


import collections
from sortedcontainers import SortedList

def parse_time(_time):
    _time = _time.zfill(4)
    res = int(_time[:2]) * 60 + int(_time[2:])
    return res

def get_badge_alerts(badge_times):

    logs = collections.defaultdict(SortedList)

    for person, time in badge_times:
        logs[person].add(parse_time(time))
    

    result = {}

    for person, minutes in logs.items():
        
        start = 0
        for end in range(len(minutes)):

            if minutes[end] - minutes[start] > 60:
                start += 1
            else:
                if (end - start + 1) >= 3:
                    res = minutes[start:end + 1]

                    for idx, t in enumerate(res):
                        res[idx] = str(int(t//60)).zfill(2) + str(int(t % 60)).zfill(2)
                        res[idx] = res[idx].lstrip("0")

                    result[person] = res
                    break

    print(result)

    return result
# Example usage:
badge_times = [
    ["Paul", "1355"], ["Jennifer", "1910"], ["Jose", "835"],
    ["Jose", "830"], ["Paul", "1315"], ["Chloe", "0"],
    ["Chloe", "1910"], ["Jose", "1615"], ["Jose", "1640"],
    ["Paul", "1405"], ["Jose", "855"], ["Jose", "930"],
    ["Jose", "915"], ["Jose", "730"], ["Jose", "940"],
    ["Jennifer", "1335"], ["Jennifer", "730"], ["Jose", "1630"],
    ["Jennifer", "5"], ["Chloe", "1909"], ["Zhang", "1"],
    ["Zhang", "10"], ["Zhang", "109"], ["Zhang", "110"],
    ["Amos", "1"], ["Amos", "2"], ["Amos", "400"],
    ["Amos", "500"], ["Amos", "503"], ["Amos", "504"],
    ["Amos", "601"], ["Amos", "602"], ["Paul", "1416"],
]

result = get_badge_alerts(badge_times)
for person, times in result.items():
    # print(f"{person}: {' '.join(times)}")
    pass

-------------------------------------------------

https://leetcode.com/problems/rank-teams-by-votes/description/
https://leetcode.com/problems/word-search/description/
https://leetcode.com/problems/all-oone-data-structure/description/


ghttps://leetcode.com/problems/stock-price-fluctuation/description/
https://leetcode.com/problems/find-k-closest-elements/description/
https://leetcode.com/problems/design-file-system/description/

Another variation of above problem.
Given a list of sentences (string having words separated by space), and an integer exactLen.
You have to generate line of exactLen (Similar to above question), by rearranging the words in above sentences but keep order maintained. If lineLength is less than exactLen, fill it with '-' which should be distributed equally from left to right.
Last line does not need to have additional '-'
e.g.
I/P : [ "The day began as still as the", "night abruptly lighted with", "brilliant flame" ], exactLen=24

O/P :
[
"The--day--began-as-still",
"as--the--night--abruptly",
"lighted--with--brilliant",
"flame" ] // <--- a single word on a line is not padded with spaces


System Design
Any concerns with Consistent Hashing for multiple servers serving music uploading/streaming service
How would you handle large files that cannot fit in on a single machine
How would you scale your backend if your app is going from a single country to international app
Pros and cons of preloading hints or loading them from server for a game. Hints could be text/image/video based.





Quality for code design
1. Clean code, working code
2. source-full ness (How I can unblock myself)
3. Adaptibilty
4. Internal DS -> TC and SC
5. 


Code Design Round
We want to implement a middleware router for our web service, which based on the path returns different strings (these would represent “functions to invoke” in a real application).
Usage:
Router.addRoute("/bar", "result")
Router.callRoute("/bar") -> "result"

follow up - search using wildcard

Router router = Router()
router.addRoute("/foo", "foo")
router.addRoute("/bar/*/baz", "bar")

router.callRoute("/bar/a/baz") -> bar

if input is this -
router.addRoute("/foo/baz", "foo")
router.addRoute("/foo/*", "bar")


https://www.zrzahid.com/who-is-the-boss-lca-for-n-array-tree/